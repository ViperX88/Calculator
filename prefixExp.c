/* prefixExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file functions are defined for the construction of expression trees
 * from prefix expressions generated by the following BNF grammar:
 *
 * <prefexp>   ::= <number> | <identifier> | '+' <prefexp> <prefexp>
 *             | '-' <prefexp> <prefexp> | '*' <prefexp> <prefexp> | '/' <prefexp> <prefexp>
 *
 * <number>      ::= <digit> { <digit> }
 *
 * <identifier> ::= <letter> { <letter> | <digit> }
 *
 * Starting pount is the token list obtained from the scanner (in scanner.c).
 */

#include <stdio.h>  /* printf */
#include <stdlib.h> /* malloc, free */
#include <assert.h> /* assert */
#include "scanner.h"
#include "recognizeExp.h"
#include "evalExp.h"
#include "prefixExp.h"
#include <string.h>

/* The function newExpTreeNode creates a new node for an expression tree.
 */

 
int correctTerm(List *lp, ExpTree *tp); // foward declaration for mutual recursion

ExpTree newExpTreeNode(TokenType tt, Token t, ExpTree tL, ExpTree tR) {
  ExpTree new = malloc(sizeof(ExpTreeNode));
  assert (new!=NULL);
  new->tt = tt;
  new->t = t;
  new->left = tL;
  new->right = tR;
  return new;
}

/* The function valueIdentifier recognizes an identifier in a token list and
 * makes the second parameter point to it.
 */

int valueIdentifier(List *lp, char **sp) {
  if (*lp != NULL && (*lp)->tt == Identifier ) {
    *sp = ((*lp)->t).identifier;
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* The function valueOperator recognizes an arithmetic operator in a token list
 * and makes the second parameter point to it.
 * Here the auxiliary function isOperator is used.
 */

int isOperator1(char c) { // accepts now also parentheses
  return ( c == '+' || c == '-' || c == '*' || c == '/' || c=='(' || c== ')' );
}

int valueOperator1(List *lp, char *cp, char c) { // checks now if our current item in the list is equal to the one we are looking for
  if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c && isOperator1(c)) {
    *cp = ((*lp)->t).symbol;
	*lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* De functie freeExpTree frees the memory of the nodes in the expression tree.
 * Observe that here, unlike in freeList, the strings in indentifier nodes
 * are not freed. The reason is that the function newExpTree does not allocate
 * memory for strings in nodes, but only a pointer to a string in a node
 * in the token list.
 */

void freeExpTree(ExpTree tr) {
  if (tr==NULL) {
    return;
  }
  freeExpTree(tr->left);
  freeExpTree(tr->right);
  free(tr);
}

	



/* The function treeExpression tries to build a tree from the tokens in the token list
 * (its first argument) and makes its second argument point to the tree.
 * The return value indicates whether the action is successful.
 * Observe that we use ordinary recursion, not mutual recursion.
 */
 
int correctTerm(List *lp, ExpTree *tp) { // checks if the term we get is ok
  double w;
  char *s;
  Token t;
  if ( valueNumber(lp,&w) ) { // checks for a number 
    t.number = (int)w; // point to its value
    *tp = newExpTreeNode(Number, t, NULL, NULL); // create leaf node
    return 1;
  }
  if ( valueIdentifier(lp,&s) ) { // checks for an identifier
    t.identifier = s; // point to its value
    *tp = newExpTreeNode(Identifier, t, NULL, NULL); // create leaf node
    return 1;
  }
  if ( valueOperator1(lp,s,'(') ) { // if not number nor identifier, then check if there are brackets
	  if (treeInfixExpression(lp,tp) && valueOperator1(lp,s,')')){
		return 1;
	  }
  } 
  return 0;
}

		
/* The function printExpTreeInfix does what its name suggests.
 */

void printExpTreeInfix(ExpTree tr) {
  if (tr == NULL) {
    return;
  }
  switch (tr->tt) {
  case Number:
    printf("%d",(tr->t).number);
   break;
  case Identifier:
    printf("%s",(tr->t).identifier);
    break;
  case Symbol:
  printf("(");
	printExpTreeInfix(tr->left);
    printf(" %c ",(tr->t).symbol);
    printExpTreeInfix(tr->right);
    printf(")");
    break;
  }
}

/* The function isNumerical checks for an expression tree whether it represents
 * a numerical expression, i.e. without identifiers.
 */

int isNumerical(ExpTree tr) {
  assert(tr!=NULL);
  if (tr->tt==Number) {
    return 1;
  }
  if (tr->tt==Identifier) {
    return 0;
  }
  return (isNumerical(tr->left) && isNumerical(tr->right));
}

/* The function valueExpTree computes the value of an expression tree that represents a
 * numerical expression.
 */
 

double valueExpTree(ExpTree tr) {  /* precondition: isNumerical(tr)) */
  double lval, rval;
  assert(tr!=NULL);
  if (tr->tt==Number) {
    return (tr->t).number;
  }
  lval = valueExpTree(tr->left);
  rval = valueExpTree(tr->right);
  switch ((tr->t).symbol) {
  case '+':
    return (lval + rval);
  case '-':
    return (lval - rval);
  case '*':
    return (lval * rval);
  case '/':
    assert( rval!=0 );
    return (lval / rval);
  default:
    abort();
  }
}

int isLeaf(ExpTree *tp){
	if ((*tp)->left == NULL && (*tp)->right == 0){
		return 1;
	}
	return 0;
}
		

int treeHighPrecedence(List *lp,ExpTree *tp){
	ExpTree tp2;
	char c;
	Token t;
	if (correctTerm(lp,tp)) { // check for number or identifier or brackets
		while (valueOperator1(lp,&c,'*') || valueOperator1(lp,&c,'/')) { // check for * or /
			if (correctTerm(lp,&tp2)) { // check for number or identifier or brackets
				t.symbol = c; // point to operator
				*tp = newExpTreeNode(Symbol,t,*tp,tp2); //create new node, inherting past nodes, left child is first term or the before created tree, right side is new value
			} else {
				return 0;
			}
		}
		return 1;
	}
	return 0;
}



int treeInfixExpression(List *lp, ExpTree *tp){
	ExpTree tp2;
	char c;
	Token t;
	if (treeHighPrecedence(lp,tp)) { // check if first item is correct (i.e. cant start with operator)
		while (valueOperator1(lp,&c,'+') || valueOperator1(lp,&c,'-')) { // check for + and - terms
			if (treeHighPrecedence(lp,&tp2)) { // check for numbers and identifiers, and if we have a * or /, then they are evaluated first
				t.symbol = c; // point to operator
				*tp = newExpTreeNode(Symbol,t,*tp,tp2);//create new node, inherting past nodes, left child is first term or the before created tree, right side is new value
			} else {
				return 0;
			}
		}
		return 1;
	}
	return 0;
}
/* the function prefExpressionExpTrees performs a dialogue with the user and tries
 * to recognize the input as a prefix expression. When it is a numerical prefix
 * expression, its value is computed and printed.
 */


ExpTree duplicate(ExpTree tr){ // copys a tree
    if(tr == NULL){
        return NULL;
    }
    /* create a copy of root node */
    ExpTree newNode = newExpTreeNode(tr->tt, tr->t, tr->left, tr->right);
    /* Recursively create clone of left and right path */
    newNode->left = duplicate(tr->left);
    newNode->right = duplicate(tr->right);
    /* Return root of copied tree */
    return newNode;
}


void simplify(ExpTree *tr){ // simplifies a tree
	if (*tr == NULL){
		return;
	}
	Token t;
	simplify(&(*tr)->left); // go down to the deepest root
	simplify(&(*tr)->right);
	if ((*tr)->tt == Symbol){
		if (((*tr)->t).symbol == '+'){ // if plus
			if ((((*tr)->left)->t).number== 0){
				*tr = ((*tr)->right);
				return;
			}
			if ((((*tr)->right)->t).number == 0){
				*tr = ((*tr)->left);
				return;
			} 
		}
		if (((*tr)->t).symbol == '-'){ // if minus
			if ((((*tr)->right)->t).number== 0){
				*tr = ((*tr)->left);
				return;
			} 			
		}
		if (((*tr)->t).symbol == '*'){ // if multiplication
			if ((((*tr)->left)->t).number== 0){
				t.number = 0;
				*tr = newExpTreeNode(Number,t,NULL,NULL);
				return;
			}
			if ((((*tr)->right)->t).number== 0){
				t.number = 0;
				*tr = newExpTreeNode(Number,t,NULL,NULL);
				return;
			}
			if ((((*tr)->left)->t).number== 1){
				*tr = ((*tr)->right);
				return;
			}
			if ((((*tr)->right)->t).number== 1){
				*tr = ((*tr)->left);
				return;
			}						 			
		}
		if (((*tr)->t).symbol == '/'){ // if division
			if ((((*tr)->right)->t).number== 1){
				*tr = ((*tr)->left);
				return;
			}			
			
		}
	}
}

ExpTree derivative(ExpTree *tA){ // finds the derivative
	ExpTree tp2, tp3, tp4, tp5, tp6;
	Token t;
	char check[] = "x";
	if ((*tA)->tt == Identifier && strcmp(((*tA)->t).identifier,check) == 0){ // if x, derviative becomes 1
		t.number = 1;
		tp3 = newExpTreeNode(Number,t,NULL,NULL);
		return tp3;
	}
	if ((*tA)->tt == Identifier || (*tA)->tt == Number){ // if not x, derivative becomes 0
		t.number = 0;
		tp3 = newExpTreeNode(Number,t,NULL,NULL);
		return tp3;
	}
	if ((*tA)->tt == Symbol){
		if(((*tA)->t).symbol == '+') { // if plus, add derivative of left side and right side
			tp2 = newExpTreeNode(Symbol,(*tA)->t,derivative(&(*tA)->left),derivative(&(*tA)->right));
			return tp2;
		}
		if(((*tA)->t).symbol == '-') { // if minus, add derivative of left side and right side
			tp2 = newExpTreeNode(Symbol,(*tA)->t,derivative(&(*tA)->left),derivative(&(*tA)->right));
			return tp2;
		}
		if(((*tA)->t).symbol == '*') { // if multiplication, add derivative of left side times right side and left side times derivative of right side
			tp3 = newExpTreeNode(Symbol,(*tA)->t,derivative(&(*tA)->left),(*tA)->right);
			tp4 = newExpTreeNode(Symbol,(*tA)->t,(*tA)->left,derivative(&(*tA)->right));
			t.symbol = '+';
			tp2 = newExpTreeNode(Symbol,t,tp3,tp4);
			return tp2;
		}
		if(((*tA)->t).symbol == '/') { // if division, like multiplication but with a minus isnated of a plus and furthermore divided by the the right side squared
			t.symbol  = '*';
			tp6 = newExpTreeNode(Symbol,t,derivative(&(*tA)->left),(*tA)->right);
			tp5 = newExpTreeNode(Symbol,t,(*tA)->left,derivative(&(*tA)->right));
			t.symbol  = '-';
			tp3 = newExpTreeNode(Symbol,t,tp6,tp5);			
			t.symbol = '*';
			tp4 = newExpTreeNode(Symbol,t,(*tA)->right,(*tA)->right);
			t.symbol  = '/';
			tp2 = newExpTreeNode(Symbol,t,tp3,tp4);
			return tp2;
		}
	}

}
				
								




void prefExpTrees() {
  char *ar;
  List tl, tl1;
  ExpTree t = NULL;
  printf("give an expression: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
    printList(tl);
    tl1 = tl;
    if ( treeInfixExpression(&tl1,&t) && tl1 == NULL) {
         /* there should be no tokens left */
      printf("in infix notation: ");
      printExpTreeInfix(t);
      printf("\n");
      if ( isNumerical(t) ) {
        printf("the value is %g\n",valueExpTree(t));
      } else {
        printf("this is not a numerical expression\n");
        ExpTree t1 = duplicate(t);
        ExpTree t2 = NULL;
        simplify(&t1);
        printf("simplified: ");
        printExpTreeInfix(t1);
        printf("\nderivative to x: ");
        t2 = derivative(&t1);
        simplify(&t2);
        printExpTreeInfix(t2);
        printf("\n");
      }
    } else {
      printf("this is not an expression\n");
    }
    freeExpTree(t);
    t = NULL;
    freeTokenList(tl);
    free(ar);
    printf("\ngive an expression: ");
    ar = readInput();
  }
  free(ar);
  printf("good bye\n");
}
